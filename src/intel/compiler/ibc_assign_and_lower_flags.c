/*
 * Copyright Â© 2019 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "ibc.h"
#include "ibc_builder.h"
#include "ibc_live_intervals.h"

#define TOTAL_FLAG_SUBNRS 4

struct ibc_assign_flags_state {
   void *mem_ctx;

   ibc_builder builder;

   const ibc_live_intervals *live;
   BITSET_WORD *read_as_flag;

   ibc_reg *assign[TOTAL_FLAG_SUBNRS];
};

static enum ibc_type
logical_flag_reg_cmp_type(const ibc_reg *reg)
{
   assert(reg->file == IBC_REG_FILE_LOGICAL);

   if (!reg->is_wlr)
      return IBC_TYPE_INVALID;

   enum ibc_type cmp_type = IBC_TYPE_INVALID;
   ibc_reg_foreach_write(ref, reg) {
      if (ref->write_instr->type != IBC_INSTR_TYPE_ALU)
         return IBC_TYPE_INVALID;

      ibc_alu_instr *alu = ibc_instr_as_alu(ref->write_instr);
      if (alu->op == IBC_ALU_OP_CMP) {
         if (cmp_type == IBC_TYPE_INVALID) {
            cmp_type = alu->src[0].ref.type;
         } else if (cmp_type != alu->src[0].ref.type) {
            return IBC_TYPE_INVALID;
         }
      }
   }

   return cmp_type;
}

static enum ibc_type
logical_flag_reg_type(const ibc_reg *reg)
{
   enum ibc_type cmp_type = logical_flag_reg_cmp_type(reg);
   if (cmp_type != IBC_TYPE_INVALID) {
      /* This flag is generated by a CMP instruction and has the same bit size
       * as the comparison operation.  This function won't be called for CMP
       * destinations as those are handled separately and ref-type won't be
       * FLAG when this is called.  For 8-bit registers, use a B type so it
       * gets sign- extended when converted to 16-bit.  For all other sizes,
       * use a W type.  Since it's a logical reg, this will automatically just
       * take the bottom 16 bits of the source register.
       */
      assert(reg->logical.bit_size >= 8);
      return IBC_TYPE_INT | MIN2(reg->logical.bit_size, 16);
   } else {
      /* This register might be participating in a phi so we assume it's
       * 16-bit.
       */
      assert(reg->logical.bit_size == 1 ||
             reg->logical.bit_size == 16);
      return IBC_TYPE_W;
   }
}

static void
free_dead_flags(uint32_t ip, struct ibc_assign_flags_state *state)
{
   for (uint8_t subnr = 0; subnr < TOTAL_FLAG_SUBNRS; subnr++) {
      if (state->assign[subnr] == NULL)
         continue;

      ibc_reg *reg = state->assign[subnr];
      const ibc_reg_live_intervals *rli = &state->live->regs[reg->index];

      uint32_t end = rli->physical_end;
      if (!BITSET_TEST(state->read_as_flag, reg->index)) {
         /* If this register is never read as a flag, we can potentially
          * significantly shorten its live range.
          */
         end = 0;
         ibc_reg_foreach_write(ref, reg)
            end = MAX2(end, ref->write_instr->index);
      }

      if (end <= ip)
         state->assign[subnr] = NULL;
   }
}

static void
free_all_flags(struct ibc_assign_flags_state *state)
{
   memset(state->assign, 0, sizeof(state->assign));
}

static int8_t
find_or_assign_flag(ibc_reg *reg, uint32_t ip,
                    bool overwrites, bool opportunistic,
                    struct ibc_assign_flags_state *state)
{
   assert(reg->file == IBC_REG_FILE_LOGICAL);

   /* First, try and look it up */
   for (uint8_t subnr = 0; subnr < TOTAL_FLAG_SUBNRS; subnr++) {
      if (state->assign[subnr] == reg)
         return subnr;
   }

   uint8_t align_mul =
      DIV_ROUND_UP(reg->logical.simd_group + reg->logical.simd_width, 16);
   uint8_t align_offset = reg->logical.simd_group >= 16;
   uint8_t num_subnrs = DIV_ROUND_UP(reg->logical.simd_width, 16);

   /* Next, try and find a free slot */
   int8_t subnr = -1;
   for (uint8_t s = align_offset; s < TOTAL_FLAG_SUBNRS; s += align_mul) {
      assert(num_subnrs == 1 || num_subnrs == 2);
      if (state->assign[s] == NULL &&
          (num_subnrs == 1 || state->assign[s + 1] == NULL)) {
         subnr = s;
         goto assigned;
      }
   }

   /* If we don't have any free slots, get rid of the register with the
    * longest remaining live range.  The hope here is that any shorter live
    * ranges will go away by themselves before we need to re-allocate them.
    * It's a heuristic.
    */
   uint32_t max_end = 0;
   for (uint8_t s = align_offset; s < TOTAL_FLAG_SUBNRS; s += align_mul) {
      for (unsigned i = 0; i < num_subnrs; i++) {
         const ibc_reg_live_intervals *iter_rli =
            &state->live->regs[state->assign[s + i]->index];
         if (iter_rli->physical_end > max_end) {
            subnr = s;
            max_end = iter_rli->physical_end;
         }
      }
   }

   /* If this is an opportunistic allocation, we only want to evict a register
    * if its live range is shorter than the register we're opportunistically
    * trying to allocation.  The idea here is that if the live range of this
    * register is longer, we would be evicted before we would be able to take
    * advantage of the opportunistic flag allocation.  It's a heuristic.
    */
   if (opportunistic && max_end < state->live->regs[reg->index].physical_end)
      return -1;

   /* If we got here, we should have found a register to use */
   assert(subnr >= 0);

   /* If subnr is even, it's possible that the same register occupies two
    * subnumbers.  Clear both if this is the case.
    */
   if (subnr % 2 == 0 && state->assign[subnr] == state->assign[subnr + 1])
      state->assign[subnr + 1] = NULL;
   state->assign[subnr] = NULL;

assigned:
   {
      ibc_builder *b = &state->builder;

      for (unsigned i = 0; i < num_subnrs; i++)
         state->assign[subnr + i] = reg;

      if (!overwrites) {
         /* We just allocated a new flag and we're not overwriting it.  Emit a
          * MOV to copy the logical value to the flag.
          */
         ibc_builder_push_group(b, reg->logical.simd_group,
                                   reg->logical.simd_width);
         unsigned lower_width = MIN2(reg->logical.simd_width, 16);
         for (unsigned g = 0; g < reg->logical.simd_width; g += lower_width) {
            ibc_builder_push_group(b, g, lower_width);
            ibc_reg_ref src = ibc_typed_ref(reg, logical_flag_reg_type(reg));
            ibc_build_alu(b, IBC_ALU_OP_MOV, ibc_null(IBC_TYPE_W),
                          ibc_flag_ref(subnr + g / 16),
                          BRW_CONDITIONAL_NZ, &src, 1);
            ibc_builder_pop(b);
         }
         ibc_builder_pop(b);
      }

      return subnr;
   }
}

static bool
rewrite_logical_flag_refs_to_w(ibc_reg_ref *ref,
                               UNUSED int8_t num_comps,
                               UNUSED uint8_t simd_group,
                               UNUSED uint8_t simd_width,
                               void *_state)
{
   if (ref->file == IBC_REG_FILE_LOGICAL && ref->type == IBC_TYPE_FLAG)
      ref->type = logical_flag_reg_type(ref->reg);

   return true;
}

void
ibc_assign_and_lower_flags(ibc_shader *shader)
{
   struct ibc_assign_flags_state state = {
      .mem_ctx = ralloc_context(NULL),
   };

   state.live = ibc_compute_live_intervals(shader, state.mem_ctx);

   /* We don't support unassigned flags yet.  It should actually be very
    * little work to support them but the code would have to be tested.
    */
   ibc_foreach_reg(reg, shader)
      assert(reg->file != IBC_REG_FILE_FLAG);

   /* Figure out what registers are read as a flag register */
   state.read_as_flag = rzalloc_array(state.mem_ctx, BITSET_WORD,
                                      BITSET_WORDS(state.live->num_regs));
   ibc_foreach_instr(instr, shader) {
      if (instr->predicate != BRW_PREDICATE_NONE &&
          instr->flag.file == IBC_REG_FILE_LOGICAL)
         BITSET_SET(state.read_as_flag, instr->flag.reg->index);
   }

   ibc_builder_init(&state.builder, shader);
   ibc_builder *b = &state.builder;

   ibc_foreach_instr_safe(instr, shader) {
      /* Start by freeing any newly dead flag registers */
      free_dead_flags(instr->index, &state);

      /* Set the cursor to before the current instruction in case
       * find_or_assign_flag needs to load a flag value.
       */
      b->cursor = ibc_before_instr(instr);

      if (instr->type == IBC_INSTR_TYPE_ALU) {
         ibc_alu_instr *alu = ibc_instr_as_alu(instr);
         if (alu->op == IBC_ALU_OP_CMP) {
            /* NOTE: In order to work with SIMD-split things, this heavily
             * relies on all the split comparison instructions to be right
             * next to each other.  This is not going to be guaranteed to be
             * true once we get a scheduler.
             */
            ibc_reg *logical = (ibc_reg *)instr->flag.reg;
            assert(logical_flag_reg_cmp_type(logical) != IBC_TYPE_INVALID);
            int8_t subnr = find_or_assign_flag(logical, instr->index,
                                               true, /* overwrite */
                                               false, /* opportunistic */
                                               &state);

            ibc_reg_ref flag_ref = ibc_flag_ref(subnr);
            ibc_flag_slice_simd_group(&flag_ref.flag,
                                      logical->logical.simd_group,
                                      instr->simd_group, instr->simd_width);
            ibc_instr_set_write_ref(&alu->instr, &alu->instr.flag, flag_ref);

            /* We can just make it write to the logical reg as its
             * destination.
             */
            logical->logical.bit_size = ibc_type_bit_size(alu->src[0].ref.type);
            ibc_reg_ref dest = ibc_typed_ref(logical, alu->src[0].ref.type);
            ibc_instr_set_write_ref(&alu->instr, &alu->dest, dest);
         } else if (alu->dest.file == IBC_REG_FILE_LOGICAL &&
                    ibc_reg_ssa_instr(alu->dest.reg) == instr &&
                    alu->dest.reg->logical.bit_size == 1) {
            /* In this case, we're some ALU instruction which is producing a
             * 1-bit destination.  This is something like an AND or OR which
             * we are using on logical things.  We're going to turn its
             * destination into a W type but we can also, if we have a free
             * reg, get a flag write for free.
             */
            ibc_reg *logical = (ibc_reg *)alu->dest.reg;
            int8_t subnr = find_or_assign_flag(logical, instr->index,
                                               true, /* overwrite */
                                               true, /* opportunistic */
                                               &state);
            if (subnr >= 0) {
               alu->cmod = BRW_CONDITIONAL_NZ;
               ibc_reg_ref flag_ref = ibc_flag_ref(subnr);
               ibc_flag_slice_simd_group(&flag_ref.flag,
                                         logical->logical.simd_group,
                                         instr->simd_group, instr->simd_width);
               ibc_instr_set_write_ref(&alu->instr, &alu->instr.flag, flag_ref);
            }
         }
      }

      if (instr->flag.file == IBC_REG_FILE_LOGICAL) {
         ibc_reg *logical = (ibc_reg *)instr->flag.reg;
         int8_t subnr = find_or_assign_flag(logical, instr->index,
                                            false, /* overwrite */
                                            false, /* opportunistic */
                                            &state);
         ibc_reg_ref flag_ref = ibc_flag_ref(subnr);
         ibc_flag_slice_simd_group(&flag_ref.flag,
                                   logical->logical.simd_group,
                                   instr->simd_group, instr->simd_width);
         instr->flag = flag_ref;
      }

      ibc_instr_foreach_read(instr, rewrite_logical_flag_refs_to_w, NULL);
      ibc_instr_foreach_write(instr, rewrite_logical_flag_refs_to_w, NULL);

      /* When we cross block boundaries, reset the allocator */
      if (instr->type == IBC_INSTR_TYPE_BRANCH)
         free_all_flags(&state);
   }

   /* Go through and assign any remaining logical flags to 16-bit */
   ibc_foreach_reg(reg, shader) {
      if (reg->file == IBC_REG_FILE_LOGICAL && reg->logical.bit_size == 1)
         reg->logical.bit_size = 16;
   }

   ralloc_free(state.mem_ctx);
}
